#!/usr/bin/env python3
"""
Small tool to generate a Readme.md file as an overview of all teaching modules
and topics.

> ./gen_readme.py
"""
from pathlib import Path
from typing import List
import re

FOLDER_SKIP_LIST = ['.git', '.github', '.mypy_cache', "__pycache__", 'tools']
README_HEADER = "# SG20: Teaching Topics"
DO_NOT_EDIT_WARNING = """<!--
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!! Please do not edit this file directly,                                    !!
!! it is auto generated by the ./gen_readme.py script.                       !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
-->
"""


def create_markdown_anchor(header: str) -> str:
    """
    Creates an markdown anchor for a header.

    >>> create_markdown_anchor("C++ compilation model")
    '(#c-compilation-model)'
    >>> create_markdown_anchor("# C++ compilation model")
    '(#c-compilation-model)'
    """
    header_anchor = header.lower()
    header_anchor = header_anchor.lstrip("# ")
    header_anchor = header_anchor.replace(' ', '-')
    header_anchor = header_anchor.replace('+', '')
    return f"(#{header_anchor})"


def create_header_link(header: str) -> str:
    """
    Creates a link for the specified header.

    >>> create_header_link("# My header")
    '[My header](#my-header)'
    """
    return f"[{header.lstrip('# ')}]{create_markdown_anchor(header)}"


class TeachingTopic:
    """Abstraction for a teaching topic."""

    LINK_REGEX = re.compile(r".*\((?P<path>.*)\)")

    def __init__(self, name: str, path: Path) -> None:
        self.__name = name
        self.__path = TeachingTopic.exchange_path_with_orignal_topic_file_path(
            path)

    @property
    def name(self) -> str:
        """Name of the topic."""
        return self.__name

    @property
    def path(self) -> Path:
        """Path to the topic file."""
        return self.__path

    @staticmethod
    def exchange_path_with_orignal_topic_file_path(path: Path) -> Path:
        """
        For topics that occure in more than one module, all except for the
        original topic file are placeholders that forward the reader to the
        original file. To make navigating easier, we automatically exchange the
        path of a topic file with the original path, so users can get directly
        to the desired file.
        """
        with open(path, "r") as topic_file:
            first_line = topic_file.readline()
            if first_line.lower().startswith("see "):
                match = TeachingTopic.LINK_REGEX.search(first_line)
                if match:
                    # Strip leading ../ because we are at the top level dir
                    return Path(match.group("path").lstrip("./"))

        return path


class TeachingModule:
    """Abstraction for a teaching module folder."""
    def __init__(self, title: str, path: Path,
                 topics: List[TeachingTopic]) -> None:
        self.__title = title
        self.__path = path
        self.__topics = topics

    @property
    def title(self) -> str:
        """Title of the teaching module."""
        return self.__title

    @property
    def path(self) -> Path:
        """Path to the module folder."""
        return self.__path

    @property
    def topics(self) -> List[TeachingTopic]:
        """List of teaching topics."""
        return self.__topics

    @staticmethod
    def convert_folder_name_to_title(folder_name: str) -> str:
        """Converts a module folder name to the corresponding title.

        >>> TeachingModule.convert_folder_name_to_title("user-defined-types")
        'User-defined types'
        >>> TeachingModule.convert_folder_name_to_title("functions")
        'Functions'
        >>> TeachingModule.convert_folder_name_to_title("error-handling")
        'Error handling'
        """
        # Special module names where we need specific name replacements
        special_cases = {
            "meta-error-handling": "Meta-error handling",
            "compile-time-programming": "Compile-time programming",
            "user-defined-types": "User-defined types",
            "object-model": "C++ object model"
        }
        title: str = ""
        if folder_name in special_cases:
            title = special_cases[folder_name]
        else:
            title = folder_name
            title = title.replace("-", " ")

        title = title.capitalize()
        return title

    @staticmethod
    def parse_module(module_dir: Path) -> 'TeachingModule':
        """Parse `TeachingModule` from file path."""
        module_title = TeachingModule.convert_folder_name_to_title(
            module_dir.name)

        teaching_topics: List[TeachingTopic] = []
        for topic_path in module_dir.iterdir():
            teaching_topics.append(TeachingTopic(topic_path.stem, topic_path))

        return TeachingModule(module_title, module_dir, teaching_topics)


def create_module_title_with_header_link(module: TeachingModule) -> str:
    """
    Creates a module title with string with a link to the corresponding header
    anchor.

    >>> create_module_title_with_header_link(TeachingModule(\
                  "C++ compilation model", Path("."),["Foo", "Bar"]))
    '[C++ compilation model](#c-compilation-model)'
    """
    return create_header_link(module.title)


def create_topic_path_link(topic: TeachingTopic) -> str:
    """
    Creates a link for the specified path.

    >>> create_topic_path_link(TeachingTopic(\
                               "Constant objects",\
                               Path("./object-model/constant-objects.md")))
    '[Constant objects](object-model/constant-objects.md)'
    """
    return f"[{topic.name}]({str(topic.path)})"


def create_topic_list_item(topic: TeachingTopic) -> str:
    """Creates a list item for a topic.

    >>> create_topic_list_item(TeachingTopic(\
                               "Constant objects",\
                               Path("./object-model/constant-objects.md")))
    '* [Constant objects](object-model/constant-objects.md)\\n'
    """
    return f"* {create_topic_path_link(topic)}\n"


def readme_generator_driver() -> None:
    """
    Run the Readme.md generation process.
    """
    readme_filename = "Readme.md"
    repo_root = Path('.')
    teaching_modules: List[TeachingModule] = []

    for directory in filter(
            lambda x: (x.is_dir() and x.name not in FOLDER_SKIP_LIST),
            repo_root.iterdir()):
        teaching_modules.append(TeachingModule.parse_module(directory))

    with open(readme_filename, 'w') as readme_file:
        readme_file.write(DO_NOT_EDIT_WARNING + "\n")
        readme_file.write(README_HEADER + "\n\n")

        # Print all module links
        readme_file.write("## Modules:\n")
        for module in teaching_modules:
            readme_file.write(
                f"* {create_module_title_with_header_link(module)}\n")

        readme_file.write("\n")

        # Print teaching topics one module at a time
        for module in teaching_modules:
            readme_file.write(f"### {module.title}\n")
            for topic in module.topics:
                readme_file.write(create_topic_list_item(topic))
            readme_file.write("\n")


if __name__ == "__main__":
    readme_generator_driver()
